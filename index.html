<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live House Price Prediction (TF.js)</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-vis@latest"></script>
    <style>
        body { font-family: sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; line-height: 1.6; }
        input, button { padding: 10px; font-size: 16px; margin: 5px 0; }
        .result { margin-top: 20px; padding: 15px; background: #f0f0f0; border-radius: 5px; font-weight: bold; }
        #status { color: gray; font-style: italic; margin-bottom: 10px; }
    </style>
</head>
<body>

    <h1>üè° Live House Price Predictor</h1>
    <p>This model runs entirely in your browser using <strong>TensorFlow.js</strong>. It trains on a small dataset of "Size vs Price" every time you load the page.</p>

    <div id="status">Status: Loading Engine...</div>

    <div style="display: flex; gap: 20px; flex-wrap: wrap;">
        <div id="plot-data" style="width: 400px; height: 300px; background: #fff; border: 1px solid #ddd;"></div>
        <div id="plot-loss" style="width: 400px; height: 300px; background: #fff; border: 1px solid #ddd;"></div>
    </div>

    <hr>

    <h3>Predict Price</h3>
    <label>Enter House Size (sq ft):</label><br>
    <input type="number" id="input-size" placeholder="e.g. 2000" disabled>
    <button id="predict-btn" disabled>Predict Price</button>

    <div class="result" id="prediction-output">
        Prediction will appear here...
    </div>

    <script>
        // --- 1. THE DATA (Hardcoded for simplicity) ---
        // Size (sq ft) vs Price ($1000s)
        const rawData = [
            { size: 1000, price: 150 }, { size: 1500, price: 200 },
            { size: 2000, price: 250 }, { size: 2500, price: 320 },
            { size: 3000, price: 400 }, { size: 1200, price: 170 },
            { size: 1800, price: 230 }, { size: 2200, price: 290 },
            { size: 1600, price: 210 }, { size: 3500, price: 460 },
            { size: 4000, price: 550 }, { size: 800, price: 120 }
        ];

        // --- 2. PREPARE DATA ---
        function convertDataToTensors(data) {
            return tf.tidy(() => {
                // Shuffle data
                tf.util.shuffle(data);

                // Extract x (inputs) and y (labels)
                const inputs = data.map(d => d.size);
                const labels = data.map(d => d.price);

                const inputTensor = tf.tensor2d(inputs, [inputs.length, 1]);
                const labelTensor = tf.tensor2d(labels, [labels.length, 1]);

                // Normalize data (Min-Max Scaling) to 0-1 range for better training
                const inputMax = inputTensor.max();
                const inputMin = inputTensor.min();
                const labelMax = labelTensor.max();
                const labelMin = labelTensor.min();

                const normalizedInputs = inputTensor.sub(inputMin).div(inputMax.sub(inputMin));
                const normalizedLabels = labelTensor.sub(labelMin).div(labelMax.sub(labelMin));

                return {
                    inputs: normalizedInputs,
                    labels: normalizedLabels,
                    inputMax, inputMin, labelMax, labelMin
                };
            });
        }

        // --- 3. CREATE MODEL ---
        function createModel() {
            const model = tf.sequential();
            // One dense layer with 1 unit (Linear Regression basically)
            model.add(tf.layers.dense({inputShape: [1], units: 1, useBias: true}));
            return model;
        }

        // --- 4. TRAIN MODEL ---
        async function trainModel(model, inputs, labels) {
            model.compile({
                optimizer: tf.train.adam(0.1), // Learning rate
                loss: 'meanSquaredError',
                metrics: ['mse']
            });

            const batchSize = 32;
            const epochs = 100;

            // Train and visualize loss
            return await model.fit(inputs, labels, {
                batchSize,
                epochs,
                shuffle: true,
                callbacks: tfvis.show.fitCallbacks(
                    document.getElementById('plot-loss'),
                    ['loss', 'mse'], 
                    { height: 200, callbacks: ['onEpochEnd'] }
                )
            });
        }

        // --- 5. MAIN EXECUTION ---
        async function run() {
            const status = document.getElementById('status');
            status.innerText = "Visualizing Data...";
            
            // Visualize Data using tfjs-vis
            const values = rawData.map(d => ({ x: d.size, y: d.price }));
            tfvis.render.scatterplot(
                document.getElementById('plot-data'),
                { values: values },
                { xLabel: 'Size (sq ft)', yLabel: 'Price (k$)', height: 300 }
            );

            // Prepare Data
            const tensorData = convertDataToTensors(rawData);
            const { inputs, labels, inputMax, inputMin, labelMax, labelMin } = tensorData;

            // Create & Train
            status.innerText = "Training Model (Watch the Loss graph)...";
            const model = createModel();
            await trainModel(model, inputs, labels);

            status.innerText = "Training Complete! Model Ready.";
            
            // Enable UI
            const inputField = document.getElementById('input-size');
            const predictBtn = document.getElementById('predict-btn');
            inputField.disabled = false;
            predictBtn.disabled = false;

            // Prediction Logic
            predictBtn.addEventListener('click', () => {
                const sizeVal = parseInt(inputField.value);
                if (!sizeVal) return;

                tf.tidy(() => {
                    // Normalize input
                    const inputTensor = tf.tensor1d([sizeVal]);
                    const normalizedInput = inputTensor.sub(inputMin).div(inputMax.sub(inputMin));

                    // Predict
                    const normalizedPred = model.predict(normalizedInput.reshape([1, 1]));

                    // Un-normalize output
                    const prediction = normalizedPred.mul(labelMax.sub(labelMin)).add(labelMin);
                    
                    const price = prediction.dataSync()[0].toFixed(2);
                    document.getElementById('prediction-output').innerHTML = 
                        `Estimated Price for <b>${sizeVal} sq ft</b> is: <b>$${price}k</b>`;
                });
            });
        }

        run();
    </script>
</body>
</html>
